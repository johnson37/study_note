# C语言中库文件的加载方式
[Reference]:(https://blog.csdn.net/u014132659/article/details/52252298)
***
Linux下使用库有三种方式，静态链接库，动态链接库和动态加载库。
-静态链接库： 在编译过程中，将所需要的库文件生成a文件并直接链接到最终的可执行文件当中，所以相对来讲，静态方式生成的image大小最大，对外界依赖小。
-动态链接库： 在编译过程中，不会将库文件链接到最终的可执行文件当中，当程序运行之初会加载所需要的动态库。知道程序运行结束在卸载，如果运行时无法找到对应的库文件，运行失败。
-动态加载库： 编译过程跟动态链接库并无区别。在运行方式上，当需要加载库文件的时候，需要显式的调用动态库。程序显得稍微复杂一点，优点也是明显的，占用的内存最小。

***
**如何区分三种编译方法**
从Makefile中可以做出简单的判断。
gcc test.cpp -L. -ltestlib
gcc会默认加载动态库，如果没有动态库则加载静态库，所以可以查看生成的库的后缀为a还是so。
对于动态加载库，在编译过程中，并不需要显式加载库文件。与之相对应的，需要在代码中显式的加载库文件，更加灵活。
```c
int (*add) (int a, int b);   //声明函数指针，用来接收dlsym返回来的函数，就是接收要用到的函数
void *phandle = dlopen("libtest.so", RTLD_LAZY);
add = dlsym(phandle, "add");   //参数add是库里定义的add函数，dlsym返回函数地址
printf("%d\n", add(2, 5));
```
***
Linux的动态库中还有另外一个特点，动态库在加载过程中，会执行_init()函数做初始化，在卸载时默认执行_fini()做些收尾的工作。
即：**如果一个可执行文件包含了动态链接库，并且动态链接库设置了_init()函数，就会发现有一部分函数，会在main函数调用之前执行。**